@model ASP1.Models.Home.HomeIoCPageModel

@*Друга точка інжекції. Сервіс-контейнер має визначитись створювати
    нвоий об'єкт чи передати посилання на попередній (раніше створений)
*@

@inject ASP1.Services.Hash.IHashService hashService;

@{
    ViewData["Title"] ="IoS";
}

<div class="text-center">
    <h1 class ="display-4"> @Model.Title </h1></div>
    <p>Inversion of control (IoC) - архітектурний піхід до проектів, згідно з яким управління
        життєвим циклом об'єктів перекладається на окремий модуль (інжектор, контейнен залежностей).
        У проєкті замість команд <code>new</code> утворюються точки інжекції, до яких впроваджуються об'єкти, створені інжектором.
        Роль контейнера можно порівняти з глобальними змінними, що є доступними в усіх околах проєкту, однак, 
        контейнер не лише містить об'єкти, а й контролює їх час життя (scope) - вирішує чи створювати різні обєкти для різних точок інжекції,
        чи передавати один і той самий об'єкт. Сервісами у цьому контексті називають саме ті об'єкти, що єдині на весь проєкт (які не перестворюються).
    </p>
    <p>
        Процес роботи за наявності IoS виглядає наступним чином:
        <ul>
            <li>Описуються сервіси - інтерфейси та їх імплементації</li>
            <li>Здійснюється реєстрація цих типів даних у контейнері сервісів</li>
            <li>У классах-споживачах оголошується інжекція цих сервісів</li>
        </ul>
        При першому зверненні до сервісу буде створено його об'єкт (інстантійовано)
        і надалі він може використовуватись повторно, якщо такий його час життя.
     </p>
     <p>
         При оголошенні сервісів слід дотримуватись принципу DIP (SOLID) - Dependency Inversion Principle - принцип
         інверсії залежності.
         (!!Не плутати терміни: "інверсія управління", "інверсія залежності", "інжекція залежності")
         DIP (не створювати залежності від реалізації, створювати від абстрацій) рекомендує описувати сервіси починаючи з 
         інтерфейсів. Чим вище абстракцію взяти, тим краще.
         <br/>
         Залежність від імплементації:
         <code>Service: AesService --> HomeController (AesService)</code>
         <br/>
         Проблема: якщо змінити сервіс AesService --> KalinaService, то доведеться переписувати усі точки імжекції для прийому нового сервісу.
         <br/>
         Рішення: створити інтерфейс (абстракцію) ICryptoService і через нього здійснювати інжекцію 
         <code>HomeController(ICryptoService)</code>, тоді зміна конкретної імплементації буде прийнятною без переробок, 
         головне, щоб обидва сервіси реалізовували один і той самий інтерфейс.
         <br/>
         Практичний висновок: сервіси завжди створюються "парою" інтерфейс-клас, навіть якщо ви там нічого не збираєтесь змінювати, 
         все одно створюються сервіси ось таким принципом: спочатку інтерфейс, а потім - імплементацію. Для більшої стійкості.
     </p>
     <p>На прикладі створення сервісів автотентифікації за паролем (слідуємо вимогам стандарту <a href="https://datatracker.ietf.org/doc/html/rfc2898">гешування</a>).
         Необхідно створити два сервіси: Hash та KDF.
     </p>
     <ul>
         <li>(одноразово) створюємо папку для всіх сервісів - Services</li>
         <li>Для кожного сервісу, оскільки файлів буде щонайменше два, також створюємо свої папки</li>
         <li>У папці сервісу Hash свторюємо два файли - інтефейс iHashService та його імплементацію Md5HashService 
             (достатній для автотентифікації, для електронних ключів недодстатній)
         </li>
         <li>Реєструємо сервіс: дивись Program.cs</li>
         <li>Інжектуємо сервііс у HomeController (див. HomeController), результат його работи передаємо до представлення
             <i>@Model.HashExample</i>
         </li>
         <li>Імітуємо задачу переходу на новий засіб гешування. За ОСP (з SOLID) не втручаємось у роботу попереднього сервісу, а створюємо новий.
             (ShaHashService) - ще один з сервісив, що годиться для цифрового підпису, більш сучасний варіант. У папці сервісу
             Hash
         </li>
         <li>Змінюємо реєстрацію сервісу (у Program.cs)</li>
     </ul>

     <h2 class="text-center">SCOPE</h2>
     <p>
         Scope - oкіл існування об'єктів сервісів.
         Для того, щоб дослідити його слід створити декілька точок інжекції та  
         перевірити однаковість посилань (референсів) на об'єкти, що в них інжектовані.
         @(hashService.Digest("123")) <br/>
         Референсний код з контролера: @Model.ServiceCode <br/>
          Референсний код з представлення: @(hashService.GetHashCode())<br/>
     </p>
     <p>
         <code>AddSingleton </code> - максимальний час існування, обєкт не змінюється як у різних 
         точках інжекції, так і при оновленні сторінки. 90% всіх сервісів<br/>
         <code>AddTransient </code> - "одноразовий" варіант, у кожній точці інжекції створюється новий об'єкт. Вкрай рідко використовується<br/>
         <code>AddScoped </code>- "середній" варіант - обєкт однаковий протягом одного запиту,але з оновленням сторінки
         створюється новий. Інколи потрібний
     </p>
     <p>
         Kdf: @Model.KdfExample
     </p>

    